module simulation
    use random
    use debug
    use others

    implicit none

contains

    subroutine Metropolis(Ai, Bj, Wij, iter, burnin, autocorr, config, Opk)
    !
    ! Metropolis simulation to generate many-body configurations based of the RBM state
    !
    !   Parameters
    !   ----------
    !   [IN] Ai : DOUBLE COMPLEX, DIMENSION(N)
    !       Biases of the visible units
    !   [IN] Bj : DOUBLE COMPLEX, DIMENSION(M)
    !       Biases of the hidden units
    !   [IN] Wij : DOUBLE COMPLEX, DIMENSION(N,M)
    !       Weights between visible and hidden units
    !   [IN] iter : INTEGER
    !       Number of steps of the simulation
    !   [IN] burnin : INTEGER
    !       Number of steps to discard before saving the results.
    !       Must be burnin < iter.
    !   [IN] autocorr : INTEGER
    !       Number of steps between two consecutive records of the results
    !   [OUT] config : INTEGER, DIMENSION((iter-burnin)/autocorr, N))
    !       Matrix with the spin configurations generated by the Metropolis.
    !       Each row represents a different realization.
    !   [OUT] Opk : DOUBLE COMPLEX, DIMENSION((iter-burnin)/autocorr, N+M+N*M))
    !       Matrix with the derivatives of the RBM wave function
    !       wrt to the network parameters.
    !       Each row represents a different realization.
    !
        implicit none
        ! parameters
        DOUBLE COMPLEX, INTENT(IN) :: Ai(:), Bj(:), Wij(:,:)
        INTEGER,        INTENT(IN) :: iter, burnin, autocorr
        INTEGER, ALLOCATABLE, INTENT(OUT) :: config(:,:)
        DOUBLE COMPLEX, ALLOCATABLE, INTENT(OUT) :: Opk(:,:)

        ! local variables
        INTEGER :: N, M, t, idx, idy, idz, idk
        INTEGER, ALLOCATABLE :: Si(:), Si_new(:)
        DOUBLE PRECISION :: u, r
        DOUBLE COMPLEX :: log_r
        DOUBLE COMPLEX, ALLOCATABLE :: Tj(:)

        ! get dimension of visible and hidden layer
        N = SIZE(Ai)
        M = SIZE(Bj)

        ! checks on RBM input dimensions
        if ( SIZE(Wij, 1) /= N .OR. SIZE(Wij, 2) /= M ) then
            print*, "[ABORT] Wrong shapes in RBM parameters"
            print*, "Visible units dimension = ", N
            print*, "Hidden  units dimension = ", M
            print*, "Weights dimensions      = ", SIZE(Wij,1), " ,", SIZE(Wij,2)
            print*, "(expected = ", N, " ,", M, ")"
            CALL ABORT()
        end if

        ! generate random initial configuration
        Si = Random_Configuration(N)
        !ALLOCATE(Si(N))
        !Si = 1
        ALLOCATE(Si_new(N))
        ! effective angles
        ALLOCATE(Tj(M))

        ! checks on iter, burnin and autocorr
        if ( iter <= 0 ) then
            print*, "[ABORT] 'Iter' must be > 0"
            CALL ABORT()
        end if

        if ( burnin < 0 .OR. burnin >= iter ) then
            print*, "[ABORT] 'burnin' must be >= 0 and < 'iter'"
            CALL ABORT()
        end if

        if ( autocorr <= 0 .OR. autocorr > iter-burnin ) then
            print*, "[ABORT] 'autocorr' must be > 0 and <= 'iter-burnin'"
        end if

        ! configurations to store
        if ( ALLOCATED(config) ) DEALLOCATE(config)
        ALLOCATE(config((iter-burnin)/autocorr, N))
        ! Opk
        if ( ALLOCATED(Opk) ) DEALLOCATE(Opk)
        ALLOCATE(Opk((iter-burnin)/autocorr, N+M+N*M))

        idy = 1

        do t = 1, iter
            CALL debugging(.FALSE., var=Si, message="+++ Configuration")
            ! choose a random spin to flip
            idx = Random_Integer(1, N+1)
            Si_new = Si
            Si_new(idx) = -Si_new(idx)
            ! calculate the log of ratio of the wave functions
            log_r = logPsiDiff(Si_new, Si, Ai, Bj, Wij)
            ! metropolis ratio
            r = ABS(EXP(log_r))**2
            ! accept the new config with probability 'r'
            CALL RANDOM_NUMBER(u)
            if ( u < r ) then
                ! accept new configuration
                Si = Si_new
            end if

            if ((t > burnin) .AND. (MOD(t, autocorr) == 0)) then
                ! calculate effective angles
                Tj = Bj + MATMUL(TRANSPOSE(Wij), Si)
                ! save the spin configuration (one per row)
                config(idy, :) = Si
                ! save the derivatives
                !   wrt Ai
                Opk(idy, 1:N) = Si
                !   wrt Bj
                Opk(idy, N+1:N+M) = TANH(Tj)
                !   wrt Wij
                idk = 1
                do idx = 1, N
                    do idz = 1, M
                        Opk(idy, N+M+idk) = Si(idx)*TANH(Tj(idz))
                        idk = idk+1
                    end do
                end do
                idy = idy + 1
            end if
        end do
        CALL debugging(.FALSE., var=Opk, message="Opk")

        ! deallocate arrays
        DEALLOCATE(Si)
        DEALLOCATE(Tj)

        RETURN

    end subroutine Metropolis

end module simulation